<script type="text/javascript">
  const URL = "https://teachablemachine.withgoogle.com/models/BIbJVnndE/"; // Replace with your model URL
  let model, webcam, labelContainer, maxPredictions;
  let mqttClient;
  let messageQueue = [];
  let lastFrameTime = 0;
  const frameInterval = 100; // ~10 FPS
  let isRunning = false; // Flag to prevent race conditions

  // MQTT Configuration
  const mqttBroker = 'broker.hivemq.com';
  const mqttPort = 8000; // Non-secure WebSocket port
  const mqttTopic = `Rat/${clientId}`;
  const clientId = 'clientId-buiKVcO8tx' + Math.random().toString(16).slice(3);

  function connectMQTT(attempt = 1, maxAttempts = 3) {
    mqttClient = new Paho.MQTT.Client(mqttBroker, mqttPort, clientId);
    mqttClient.onConnectionLost = onConnectionLost;
    mqttClient.onMessageArrived = onMessageArrived;

    mqttClient.connect({
      useSSL: false,
      onSuccess: onConnect,
      onFailure: (err) => {
        console.error('MQTT connection failed:', err);
        labelContainer.innerText = `MQTT Connection Failed: ${err.errorMessage}. Retrying...`;
        if (attempt < maxAttempts) {
          console.log(`Retrying MQTT connection (${attempt + 1}/${maxAttempts})...`);
          setTimeout(() => connectMQTT(attempt + 1, maxAttempts), 2000);
        }
      }
    });
  }

  function onConnect() {
    console.log('Connected to MQTT broker');
    labelContainer.innerText = "Connected to MQTT broker";
    while (messageQueue.length > 0) {
      const message = messageQueue.shift();
      mqttClient.send(message);
      console.log('Sent queued MQTT message:', message.payloadString);
    }
  }

  function onConnectionLost(responseObject) {
    if (responseObject.errorCode !== 0) {
      console.error('MQTT connection lost:', responseObject.errorMessage);
      labelContainer.innerText = `MQTT Connection Lost: ${responseObject.errorMessage}`;
    }
  }

  function onMessageArrived(message) {
    console.log('MQTT message received:', message.payloadString);
  }

  async function init(facingMode) {
    // Prevent multiple initializations
    if (isRunning) {
      console.log("Already running, please stop first.");
      return;
    }
    isRunning = true;

    labelContainer = document.getElementById("label-container");
    labelContainer.innerText = "Initializing...";

    // Check for getUserMedia support
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      labelContainer.innerText = "Error: Webcam not supported by this browser.";
      isRunning = false;
      return;
    }

    const modelURL = URL + "model.json";
    const metadataURL = URL + "metadata.json";

    // Load the model
    try {
      labelContainer.innerText = "Loading model...";
      model = await tmImage.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();
      console.log("Model loaded successfully, classes:", maxPredictions);
    } catch (e) {
      console.error("Model loading failed:", e);
      labelContainer.innerText = `Error: Failed to load model. Ensure the URL (${URL}) is correct and accessible.`;
      isRunning = false;
      return;
    }

    // Initialize webcam
    try {
      labelContainer.innerText = "Setting up webcam...";
      const scale = window.devicePixelRatio || 1;
      webcam = new tmImage.Webcam(224 * scale, 224 * scale, false);
      await webcam.setup({ facingMode: facingMode });
      await webcam.play();
      if (!webcam.canvas) {
        throw new Error("Webcam canvas not initialized");
      }
      console.log("Webcam initialized, width:", webcam.canvas.width, "facingMode:", facingMode);
      webcam.canvas.style.width = "224px";
      webcam.canvas.style.height = "224px";
      document.getElementById("webcam-container").appendChild(webcam.canvas);
    } catch (e) {
      console.error("Webcam setup failed:", e);
      let errorMessage = e.message;
      if (e.name === "NotAllowedError") {
        errorMessage = "Camera access denied. Please allow camera permissions.";
      } else if (e.name === "NotFoundError") {
        errorMessage = "No camera found. Please ensure a camera is available.";
      } else if (e.message.includes("Requested device not found")) {
        errorMessage = "Requested camera not found. Try switching to another camera.";
      }
      labelContainer.innerText = `Error: ${errorMessage}`;
      isRunning = false;
      return;
    }

    // Set up label container
    try {
      labelContainer.innerHTML = "";
      for (let i = 0; i < maxPredictions; i++) {
        const div = document.createElement("div");
        div.id = `prediction-${i}`; // Assign unique IDs for safety
        labelContainer.appendChild(div);
      }
      console.log("Label container initialized with", maxPredictions, "divs");
    } catch (e) {
      console.error("Label container setup failed:", e);
      labelContainer.innerText = `Error: Failed to set up label container.`;
      isRunning = false;
      return;
    }

    // Connect to MQTT
    try {
      labelContainer.innerText = "Connecting to MQTT...";
      connectMQTT();
    } catch (e) {
      console.error("MQTT setup failed:", e);
      labelContainer.innerText = `Warning: MQTT connection failed, but continuing with predictions.`;
    }

    // Start prediction loop
    labelContainer.innerText = "Starting predictions...";
    window.requestAnimationFrame(loop);
  }

  async function loop(timestamp) {
    if (!isRunning || !webcam) return; // Stop loop if not running or webcam is null
    if (timestamp - lastFrameTime < frameInterval) {
      window.requestAnimationFrame(loop);
      return;
    }
    lastFrameTime = timestamp;
    try {
      await webcam.update();
      await predict();
    } catch (e) {
      console.error("Prediction error:", e);
      labelContainer.innerText = `Error during prediction: ${e.message}`;
    }
    window.requestAnimationFrame(loop);
  }

  async function predict() {
    if (!isRunning || !model || !webcam || !labelContainer) {
      console.warn("Prediction skipped: System not fully initialized");
      return;
    }

    try {
      const prediction = await model.predict(webcam.canvas);
      const predictionData = [];

      // Ensure child nodes exist
      if (labelContainer.childNodes.length < maxPredictions) {
        console.warn("Label container has fewer nodes than expected:", labelContainer.childNodes.length, "<", maxPredictions);
        labelContainer.innerText = "Error: Label container not properly initialized.";
        return;
      }

      for (let i = 0; i < maxPredictions; i++) {
        if (!labelContainer.childNodes[i]) {
          console.warn(`Child node ${i} is undefined`);
          continue; // Skip if child node is undefined
        }
        const classPrediction = `${prediction[i].className}: ${prediction[i].probability.toFixed(2)}`;
        labelContainer.childNodes[i].innerHTML = classPrediction;
        predictionData.push({
          className: prediction[i].className,
          probability: prediction[i].probability.toFixed(2)
        });
      }

      // Send or queue predictions
      const message = new Paho.MQTT.Message(JSON.stringify(predictionData));
      message.destinationName = mqttTopic;
      if (mqttClient && mqttClient.isConnected()) {
        mqttClient.send(message);
        console.log('Sent MQTT message:', JSON.stringify(predictionData));
      } else {
        messageQueue.push(message);
        console.log('Queued MQTT message:', JSON.stringify(predictionData));
      }
    } catch (e) {
      console.error("Prediction failed:", e);
      labelContainer.innerText = `Error in prediction: ${e.message}`;
    }
  }

  function stop() {
    isRunning = false;
    if (webcam) {
      webcam.stop();
      document.getElementById("webcam-container").innerHTML = '';
      webcam = null;
    }
    if (mqttClient && mqttClient.isConnected()) {
      mqttClient.disconnect();
      console.log('Disconnected from MQTT broker');
      mqttClient = null;
    }
    messageQueue = [];
    if (labelContainer) {
      labelContainer.innerText = "Stopped.";
    }
  }
</script>
